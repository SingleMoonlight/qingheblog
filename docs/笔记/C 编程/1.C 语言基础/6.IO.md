---
title: IO
createTime: 2023/06/10 14:30:54
permalink: /c/c-io/
excerpt: 标准输入输出标准库实现了简单的文本输入／输出模式。文本流由一系列行组成，每一行的结尾是一个换行符。如果系统没有遵循这种模式，则标准库将通过一些措施使得该系统适应这种模式。例如，标准库可以在输入端将回车符和换行符都转换为换行符，而在输出端进行反向转换。最简单的输入机制是使用 getchar 函数...
---
## 标准输入输出
标准库实现了简单的文本输入／输出模式。文本流由一系列行组成，每一行的结尾是一个换行符。如果系统没有遵循这种模式，则标准库将通过一些措施使得该系统适应这种模式。例如，标准库可以在输入端将回车符和换行符都转换为换行符，而在输出端进行反向转换。

最简单的输入机制是使用 getchar 函数从标准输入中（一般为键盘）一次读取一个字符：

```c
int getchar(void)
```

getchar 函数在每次被调用时返回下一个输入字符。若遇到文件结尾，则返回 EOF。符号常量 EOF 在头文件<stdio.h> 中定义，其值一般为 -1，但程序中应该使用 EOF 来测试文件是否结束，这样才能保证程序同 EOF 的特定值无关。

函数 putchar 用于输出数据。putchar(c) 将字符 c 送至标准输出上，在默认情况下，标准输出为屏幕显示。如果没有发生错误，则函数 putchar 将返同输出的字符；如果发生了错误，则返回 EOF。

```c
int putchar(int)
```

函数 printf 也向标准输出设备上输出数据。我们在程序中可以交叉调用函数 putchar和 printf，输出将按照函数调用的先后顺序依次产生。

使用输入／输出库函数的每个源程序文件必须在引用这些函数之前包含下列语句

```c
#include <stdio.h>
```

当文件名用一对尖括号<和>括起来时，预处理器将在由具体实现定义的有关位置中查找指定的文件（例如，在UNIX 系统中，文件一般放在目录/usr/include中）。

许多程序只从一个输入流中读取数据，并且只向一个输出流中输出数据。对于这样的程序，只需要使用函数getchar、putchar 和printf 实现输入／输出即可，并且对程序来说已经足够了。

## 格式化输入输出
### printf
输出函数 printf 将内部数值转换为字符的形式，其声明如下：

```c
int printf(char *format, arg1, arg2, ...)
```

函数 printf 在输出格式 format 的控制下，将其参数进行转换与格式化，并在标准输出设备上打印出来。它的返回值为打印的字符数。

格式字符串包含两种类型的对象：普通字符和转换说明。在输出时，普通字符将原样不动地复制到输出流中，而转换说明并不直接输出到输出流中，而是用于控制 printf 中参数的转换和打印，每个转换说明都由一个百分号字符（即 %）开始，并以一个转换字符结束。在字符 % 和转换字符中间可能依次包含下列组成部分：

+ 负号，用于指定被转换的参数按照左对齐的形式输出。
+ 数，用于指定最小字段宽度。转换后的参数将打印不小于最小字段宽度的字段。如果有必要，字段左边（如果使用左对齐的方式，则为右边）多余的字符位置用空格填充以保证最小字段宽。
+ 小数点，用于将字段宽度和精度分开。
+ 数，用于指定精度，即指定字符串中要打印的最大字符数、浮点数小数点后的位数、整型最少输出的数字数目。
+ 字母h或l，字母h表不将整数作为short类型打印，字母l表示将整数作为long类型打印。

具体如下表：

| specifier（说明符） | 输出 |
| --- | --- |
| c | 字符 |
| d 或 i | 有符号十进制整数 |
| e | 使用 e 字符的科学科学记数法（尾数和指数） |
| E | 使用 E 字符的科学科学记数法（尾数和指数） |
| f | 十进制浮点数 |
| g | 自动选择 %e 或 %f 中合适的表示法 |
| G | 自动选择 %E 或 %f 中合适的表示法 |
| o | 有符号八进制 |
| s | 字符的字符串 |
| u | 无符号十进制整数 |
| x | 无符号十六进制整数 |
| X | 无符号十六进制整数（大写字母） |
| p | 指针地址 |
| n | 无输出 |
| % | 字符 |


| flags（标识） | 描述 |
| --- | --- |
| - | 在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。 |
| + | 强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。 |
| (space) | 如果没有写入任何符号，则在该值前面插入一个空格。 |
| # | 与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。  与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。  与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。 |
| 0 | 在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。 |


| width（宽度） | 描述 |
| --- | --- |
| (number) | 要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。 |
| * | 宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 |


| precision（精度） | 描述 |
| --- | --- |
| .number | 对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。  对于 e、E 和 f 说明符：要在小数点后输出的小数位数。  对于 g 和 G 说明符：要输出的最大有效位数。  对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。  对于 c 类型：没有任何影响。  当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。 |
| .* | 精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。 |


| length（长度） | 描述 |
| --- | --- |
| h | 参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。 |
| l | 参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。 |
| L | 参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。 |


下面的实例演示了 printf() 函数的用法。

```c
#include <stdio.h>

int main ()
{
   int ch;

   for (ch = 75 ; ch <= 100; ch++) 
   {
      printf("ASCII 值 = %d, 字符 = %c\n", ch , ch );
   }

   return(0);
}
```

编译并运行上面的程序，将产生以下结果：

```plain
ASCII 值 = 75, 字符 = K
ASCII 值 = 76, 字符 = L
ASCII 值 = 77, 字符 = M
ASCII 值 = 78, 字符 = N
ASCII 值 = 79, 字符 = O
ASCII 值 = 80, 字符 = P
ASCII 值 = 81, 字符 = Q
ASCII 值 = 82, 字符 = R
ASCII 值 = 83, 字符 = S
ASCII 值 = 84, 字符 = T
ASCII 值 = 85, 字符 = U
ASCII 值 = 86, 字符 = V
ASCII 值 = 87, 字符 = W
ASCII 值 = 88, 字符 = X
ASCII 值 = 89, 字符 = Y
ASCII 值 = 90, 字符 = Z
ASCII 值 = 91, 字符 = [
ASCII 值 = 92, 字符 = \
ASCII 值 = 93, 字符 = ]
ASCII 值 = 94, 字符 = ^
ASCII 值 = 95, 字符 = _
ASCII 值 = 96, 字符 = `
ASCII 值 = 97, 字符 = a
ASCII 值 = 98, 字符 = b
ASCII 值 = 99, 字符 = c
ASCII 值 = 100, 字符 = d
```

函数 sprintf 执行的转换和函数 printf 相同，但它将输出保存到一个字符串中：

```c
int sprintf(char *string, char *format, arg1, arg2, ...)
```

sprintf 函数和 printf 函数一样，按照 format 格式格式化参数序列 arg1、arg2、…，但它将输出结果存放到 string 中，而不是输出到标准输出中。当然，string 必须足够大以存放输出结果。

### scanf
输入函数 scanf 对应于输出函数 printf，它在与后者相反的方向上提供同样的转换功能。声明形式如下：

```c
int scanf(char *format, ...)
```

scanf 函数从标准输入中读取字符序列，按照 format 中的格式说明对字符序列进行解释，并把结果保存到其余的参数中。其它所有参数都必须是指针，用于指定经格式转换后的相应输入保存的位置。

当 scanf 函数扫描完其格式串，或者碰到某些输入无法与格式控制说明匹配的情况时，该函数将终止，同时，成功匹配并赋值的输入项的个数将作为函数值返回，所以，该函数的返回值可以用来确定已匹配的输入项的个数。

格式串通常都包含转换说明，用于控制输入的转换。格式串可能包含下列部分：

+ 空格或制表符，在处理过程中将被忽略。
+ 普通字符（不包括%），用于匹配输入流中下一个非空白符字符。
+ 转换说明，依次由一个%、一个可选的赋值禁止字符*、一个可选的数值（指定最大字段宽度）、一个可选的h、l 或L 字符（指定目标对象的宽度）以及一个转换字符组成。

具体与printf类似，这里不再赘述。

另外还有一个输入函数 sscanf，它用于从一个字符串（而不是标准输入）中读取字符序列：

```c
int sscanf(char *string, char *format, arg1, arg2, ...)
```

它按照格式参数 format 中规定的格式扫描字符串 string，并把结果分别保存到 arg1、arg2、…这些参数中。这些参数必须是指针。

## 文件输出输入
### fopen
在读写一个文件之前，必须通过库函数 fopen 打开该文件。fopen 用类似于 x.c 或 y.c 这样的外部名与操作系统进行某些必要的连接和通信（我们不必关心这些细节），并返回一个随后可以用于文件读写操作的指针。

该指针称为文件指针，它指向一个包含文件信息的结构，这些信息包括：缓冲区的位置、缓冲区中当前字符的位置、文件的读或写状态、是否出错或是否已经到达文件结尾等等。用户不必关心这些细节，因为<stdio.h>中已经定义了一个包含这些信息的结构 FILE。在程序中只需按照下列方式声明一个文件指针即可：

```c
FILE *fp;
FILE *fopen(char *name, char *mode);
```

在本例中，fp 是一个指向结构 FILE 的指针，并且，fopen 函数返回一个指向结构 FILE 的指针。注意，FILE 像 int 一样是一个类型名，而不是结构标记。它是通过typedef定义的。

在程序中，可以这样调用fopen函数：

```c
fp = fopen(name, mode);
```

fopen 的第一个参数是一个字符串，它包含文件名。第二个参数是访问模式，也是一个字符串，用于指定文件的使用方式。允许的模式包括：读（“r”）、写（“w”）及追加（“a”）。某些系统还区分文本文件和二进制文件，对后者的访问需要在模式字符串中增加字符“b”。

如果打开一个不存在的文件用于写或追加，该文件将被创建（如果可能的话）。当以写方式打开一个已存在的文件时，该文件原来的内容将被覆盖。但是，如果以追加方式打开一个文件，则该文件原来的内容将保留不变。读一个不存在的文件会导致错误，其它一些操作也可能导致错误，比如试图读取一个无读取权限的文件。如果发生错误， fopen 将返回 NULL。

文件被打开后，就需要考虑采用哪种方法对文件进行读写。有多种方法可供考虑，其中，getc 和 putc 函数最为简单。getc 从文件中返回下一个字符，它需要知道文件指针，以确定对哪个文件执行操作：

```c
int getc(FILE *fp)
```

getc 函数返回 fp 指向的输入流中的下一个字符。如果到达文件尾或出现错误，该函数将返回 EOF，

putc 是一个输出函数，如下所示：

```c
int putc(int c, FILE *fp)
```

该函数将字符 c 写入到 fp 指向的文件中，并返回写入的字符。如果发生错误，则返回 EOF。

类似于 getchar 和 putchar，getc 和 putc 是宏而不是函数。

对于文件的格式化输入或输出，可以使用函数 fscanf 和 fprintf。它们与 scanf 和 printf 函数的区别仅仅在于它们的第一个参数是一个指向所要读写的文件的指针，第二个参数是格式串。如下所示：

```c
int fscanf(FILE *fp, char *format, ...)
int fprintf(FILE *fp, char *format, ...)
```

### fclose
```c
int fclose(FILE *fp)
```

执行和 fopen 相反的操作，它断开由 fopen 函数建立的文件指针和外部名之间的连接，并释放文件指针以供其它文件使用。因为大多数操作系统都限制了一个程序可以同时打开的文件数，所以，当文件指针不再需要时就应该释放，这是一个好的编程习惯，

对输出文件执行 fclose 还有另外一个原因：它将把缓冲区中由 putc 函数正在收集的输出写到文件中。当程序正常终止时，程序会自动为每个打开的文件调用 fclose 函数。

## 行输入输出
标准库提供了一个输入函数 fgets：

```c
char *fgets(char *line, int maxline, FILE *fp)
```

fgets 函数从 fp 指向的文件中读取下一个输入行（包括换行符），并将它存放在字符数组 line 中，它最多可读取 maxline-1个字符。读取的行将以 '\0' 结尾保存到数组中。通常情况下，fgets 返回 line，但如果遇到了文件结尾或发生了错误，则返回 NULL。

输出函数 fputs 将一个字符串（不需要包含换行符）写入到一个文件中：

```c
int fputs(char *line, FILE *fp)
```

如果发生错误，该函数将返回 EOF，否则返回一个非负值。

库函数 gets 和 puts 的功能与 fgets 和 fputs 函数类似，但它们是对 stdin 和 stdout 进行操作。有一点我们需要注意，gets 函数在读取字符串时将删除结尾的换行符（'\n'），而 puts 函数在写入字符串时将在结尾添加一个换行符。

