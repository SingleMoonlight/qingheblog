---
title: 基础语法
createTime: 2023/03/26 12:35:20
permalink: /java/java-basic-grammar/
---
## 数据类型
Java 中共有四类基本数据类型，分别是整数型、浮点型、字符型和布尔型。

整数型：byte、short、int、long

浮点型：float、double

字符型：char

布尔型：boolean

| 数据类型 | 位数 | 默认值 |
| --- | --- | --- |
| byte | 8 | 0 |
| short | 16 | 0 |
| int | 32 | 0 |
| long | 64 | 0L |
| float | 32 | 0.0f |
| double | 64 | 0.0d |
| char | 16 | 'u0000' |
| boolean | 8 | false |


## 数据类型的转换
Java 变量的数据类型之间可以相互转换，转换的方分为两种“自动类型转换”和“强制类型转换”。不同数据之间进行混合运算时必须转换为同种类型后才能进行运算。转换时，系统按照数据类型的表示范围由小到大的转换原则自动进行。数据类型的表示范围由小到大的顺序为：

```java
byte -> short -> char -> int -> long -> float -> double
```

需要注意的是，不能对 boolean 类型进行类型转换；转换过程中可能会导致溢出或损失精度；由大到小需要强制转换，例如：

```java
int i =128;   
byte b = (byte)i;
```

## 运算符
### 算术运算符
| 操作符 | 描述 |
| --- | --- |
| + | 加法：相加运算符两侧的值 |
| - | 减法：左操作数减去右操作数 |
| * | 乘法：相乘操作符两侧的值 |
| / | 除法：左操作数除以右操作数 |
| ％ | 取余：左操作数除以右操作数的余数 |
| ++ | 自增：操作数的值增加1 |
| -- | 自减：操作数的值减少1 |


### 关系运算符
| 运算符 | 描述 |
| --- | --- |
| == | 检查如果两个操作数的值是否相等，如果相等则条件为真 |
| != | 检查如果两个操作数的值是否相等，如果值不相等则条件为真 |
| > | 检查左操作数的值是否大于右操作数的值，如果是那么条件为真 |
| < | 检查左操作数的值是否小于右操作数的值，如果是那么条件为真 |
| >= | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真 |
| <= | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真 |


### 逻辑运算符
| 操作符 | 描述 |
| --- | --- |
| && | 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真 |
| | | | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真 |
| ！ | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false |


### 位运算符
| 操作符 | 描述 |
| --- | --- |
| ＆ | 如果相对应位都是1，则结果为1，否则为0 |
| | | 如果相对应位都是 0，则结果为 0，否则为 1 |
| ^ | 如果相对应位值相同，则结果为0，否则为1 |
| 〜 | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0 |
| << | 按位左移运算符。左操作数按位左移右操作数指定的位数 |
| >> | 按位右移运算符。左操作数按位右移右操作数指定的位数 |
| >>> | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充 |


### 赋值运算符
| 操作符 | 描述 |
| --- | --- |
| = | 简单的赋值运算符，将右操作数的值赋给左侧操作数 |
| += | 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数 |
| -= | 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数 |
| *= | 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数 |
| /= | 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数 |
| ％= | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 |
| <<= | 左移位赋值运算符 |
| >>= | 右移位赋值运算符 |
| ＆= | 按位与赋值运算符 |
| ^= | 按位异或赋值操作符 |
| |= | 按位或赋值操作符 |


### 其他运算符
#### 三元运算符
```java
条件表达式 ? 表达式1 : 表达式2
```

如果条件表达式成立，执行表达式1，如果条件表达式不成立，则执行表达式2。

#### instanceof 运算符
```java
(对象) instanceof (类类型或接口类型)
```



用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型），返回结果为布尔型。

## 运算符优先级
下表从上到下优先级递减。

| 类别 | 操作符 | 关联性 |
| --- | --- | --- |
| 后缀 | () [] . (点操作符) | 左到右 |
| 一元 | expr++ expr-- | 从左到右 |
| 一元 | ++expr --expr + - ～ ！ | 从右到左 |
| 乘性 | * /％ | 左到右 |
| 加性 | + - | 左到右 |
| 移位 | >> >>>  << | 左到右 |
| 关系 | > >= < <= | 左到右 |
| 相等 | == != | 左到右 |
| 按位与 | ＆ | 左到右 |
| 按位异或 | ^ | 左到右 |
| 按位或 | | | 左到右 |
| 逻辑与 | && | 左到右 |
| 逻辑或 | | | | 左到右 |
| 条件 | ？： | 从右到左 |
| 赋值 | = + = - = * = / =％= >> = << =＆= ^ = | = | 从右到左 |
| 逗号 | ， | 左到右 |


## 数组
### 一维数组
```java
type <数组名>[] = new type[<元素个数>]
```

### 二维数组
```java
type <数组名>[][] = new type[<行元素个数>][<列元素个数>]
```

### 字符串
```java
// 创建空的字符串
String s1 = new String ();
// 由字符数组创建字符串
char ch[] = { 's', 't', 'r', 'i', 'n', 'g'};
String s2 = new String (ch);
// 直接使用字符串常量初始化字符串
String s3 = "HelloWorld!";
```

在这里，运算符“+”除了作为算数运算符使用外，还可以用于连接字符串。其规则为："abc" + "def" = "abcdef"。

## Java程序执行控制流程
### 三种程序结构
#### 顺序
自上而下顺序执行程序语句。

#### 选择
根据条件选择执行程序语句。

if ：如果条件表达式成立，则执行大括号里的程序代码，否则不执行。

```java
if(条件表达式) {
	// 程序代码
}
```

if...else ：如果条件表达式成立，则执行程序代码1，否则执行程序代码2。

```java
if(条件表达式) {
	// 程序代码1
} else {
	// 程序代码2
}
```

if...else if ：多分支时，那一个条件表达式成立就执行相应的程序代码。

```java
if(条件表达式1) {
    // 程序代码1
} else if(条件表达式2) {
    // 程序代码2
} else if(条件表达式3) {
    // 程序代码3
} else {
    // 程序代码4
}
```

switch...case ：当变量的值等于哪一个值时，就执行相应的程序代码，如果变量的值不等于任何一个 case 的情况，就执行 default 里的程序代码。需要注意的是，根据变量的值的情况执行相应的程序代码的前提是每一个 case 里均有 break 语句用于终止程序，如果没有 break 语句，程序会顺序执行直到退出。

```java
switch(变量) {
    case 值1: {
        // 程序代码1
        break;
    }
    case 值2: {
        // 程序代码2
        break;
    }
    case 值3: {
        // 程序代码3
        break;
    }
    case 值4: {
        // 程序代码4
        break;
    }
    default: {
        // 程序代码5
        break;
    }
}
```

#### 循环
根据条件循环执行程序语句。

while ：首先判断条件表达式是否成立，如果成立，则循环执行大括号里的程序代码，直至条件表达式不成立；如果不成立，则不执行。

```java
while(条件表达式) {
    // 程序代码
}
```

do...while ：首先执行大括号里的程序代码，然后判断条件表达式是否成立，如果成立，则继续执行大括号里的程序代码，直至条件表达式不成立；如果不成立，则不再继续执行。

```java
do {
    // 程序代码
} while(条件表达式)
```

for ：首先执行语句1（仅执行一次），然后判断条件表达式是否成立，如果成立则执行大括号里的程序代码，接着执行程序语句2，然后再次判断条件表达式是否成立，如此循环直至条件表达式不成立，不再执行。

```java
for(程序语句1; 条件表达式; 程序语句2) {
    // 程序代码
}
```

for...each ：JDK 1.5 引入的一种简化后的 for 语句，方便对数组和集合进行遍历。

```java
for(元素类型 元素 : 遍历对象) {
    // 程序代码
}
```

#### 跳转语句
break ：强行退出循环，不在继续执行循环体了（switch 中除外）。

continue ：退出当前轮次的循环，强制执行下一轮循环。

return ：返回语句，返回到调用该方法的地方继续执行。

## 重要概念
### 类（class）
类是一个模板，它描述一类对象的行为和状态。例如，大学生可以看作是一个类，任何一个大学生都属于这个群体。

声明格式：

```java
// 类首
[<修饰符>] class <类名> [extends <超类名>] [implements <接口名>] {
    // 类主体
    [<修饰符>] [static] [final] [transient] <变量类型> <变量名>	// 成员变量
        
    [<修饰符>] <返回类型> <方法名> ([<参数列表>]) [throws<异常类>] {	// 成员方法
        // 方法体
    }
}
```

### 对象（object）
对象是类的一个实例，有状态和行为。例如，大学生是一个类，对于任何一个大学生来说都有姓名、年龄、爱好、成绩等状态，有学习、运动、吃饭、睡觉等行为。

声明格式：

```java
<类名> <对象名> = new <类名>([<构造方法参数列表>])
```

### 变量
程序运行期间，随时可能产生一些临时数据，程序会将这些数据保存在内存单元中，每个内存单元都用一个标识符也就是变量名来标识，我们可通过变量名来访问对应的存储空间。

#### 局部变量
在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。

#### 成员变量
成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。

#### 类变量
类变量也声明在类中，方法体之外，但必须声明为 static 类型，因此也叫静态变量。

### 方法
方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。Java 语言里的方法（Method）和其它语言里如 C 语言中的函数（Function）不完全相同，在某种程度上可以认为是一样的。

#### 构造方法
字面意思，当创造一个类的对象时，就要调用构造方法，构造方法没有参数类型和返回值。每个类都有构造方法，如果没有显式地（自定义地）为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。

#### 静态方法
静态方法使用 static 修饰符修饰，可以通过类名或对象调用，但通常选择直接使用类名调用，不建议通过对象调用。

#### 一般方法
必须通过对象来调用。

```java
// Student类
public class Student {
    // 属性
    String name;
    int age;
    String hobby;
    int score;

    // 构造方法（这里仅有一个参数name）
    Student(String name) {
        this.name = name;
    }

    // 一般方法
    void study() {
        System.out.println("I love learning.");
    }
    void sport() {
        System.out.println("I like doing sports.");
    }
    void eat() {
        System.out.println("I like to eat.");
    }
    void sleep() {
        System.out.println("I like sleeping.");
    }
}
```

## Java修饰符
### 访问控制修饰符
| 修饰符 | 当前类 | 同一包中的类 | 子类(同一包) | 子类(不同包) | 其他包中的类 |
| --- | --- | --- | --- | --- | --- |
| public | Y | Y | Y | Y | Y |
| protected | Y | Y | Y | Y/N | N |
| default | Y | Y | Y | N | N |
| private | Y | N | N | N | N |


> 基类的 protected 成员是包内可见的，并且对子类可见；
>
> 若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。
>
> [关于protected的详细介绍](https://www.runoob.com/w3cnote/java-protected-keyword-detailed-explanation.html)
>

### 非访问控制修饰符
| 修饰符 | 说明 |
| --- | --- |
| static | static 修饰符，用来修饰类方法和类变量 |
| final | final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的 |
| abstract | 用来创建抽象类和抽象方法 |
| synchronized | synchronized 关键字声明的方法同一时间只能被一个线程访问 |
| transient | 表示一个临时变量 |
| volatile | volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值 |




## 
